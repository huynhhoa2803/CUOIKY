# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1i-CmINQOWLFYPQ2J760HldFnxjMgJJrr
"""

from google.colab import drive
drive.mount('/content/gdrive')

from google.colab import files
uploaded = files.upload()

"""#B1_Import libraries

"""

# Commented out IPython magic to ensure Python compatibility.
import os 
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns 
# %matplotlib inline

"""#2.Load the Dataset
Tôi sẽ sử dụng bộ dữ liệu giá nhà ở California được tìm thấy trên Kaggle. Dữ liệu chứa các cột sau:

'Kinh độ' 'Vĩ độ' 'Tuổi trung bình của ngôi nhà' 'Total_Rooms' 'Tổng số phòng ngủ' 'Dân số' 'Hộ gia đình' 'Median_ income' 'Median_house_value' 'Ocean_proximity' Tiếp theo, chúng ta đọc tập dữ liệu vào khung dữ liệu Pandas.

"""

df_housing = pd.read_csv('housing.csv')

df_housing.info

df_housing.head()

#Hãy check có giá trị nào null kh
df_housing.describe()

df_housing.info()

# Phương thức isnull() được sử dụng để kiểm tra và quản lý các giá trị NULL trong khung dữ liệu.
df_housing.isnull().sum()

#Điền giá trị null total_ bedrooms với giá trị trung bình của cột này
df_housing['total_bedrooms'].fillna((df_housing['total_bedrooms'].mean()), inplace=True)

#Kiểm tra lại các giá trị null của chúng tôi
df_housing.isnull().sum()

"""#Kiểm tra xem có bao nhiêu giá trị duy nhất có ocean_proximity để tạo hình nộm"""

expected_value = df_housing["total_bedrooms"].mean()

print("Giá trị trung bình mẫu của cột 'total_bedrooms' là:", expected_value)

df_housing['ocean_proximity'].unique()

df_housing_dummies = pd.get_dummies(df_housing['ocean_proximity'])

df_housing_dummies

# Thả cột vì nó hiện được mã hóa
df_housing = df_housing.drop('ocean_proximity',axis = 1)
# Tham gia df được mã hóa
df = df_housing.join(df_housing_dummies)
df .head()

"""#B4.Trực quan hóa dữ liệu

"""

# Kiểm tra kiểu dữ liệu của các cột
print(df.dtypes)

sns.pairplot(df_housing)

# Tìm hiểu các phân phối của các đặc trưng
df.hist(bins=50, figsize=(20,15))
plt.show()

# Tương quan giữa các đặc trưng
f,ax = plt.subplots(figsize=(10, 8))
sns.heatmap(df.corr(), annot=True, linewidths=.5, fmt= '.2f',ax=ax)
plt.show()

"""#Tạo chức năng plotHistogram để vẽ tần suất của mọi tính năng"""

def plotHistogram(column):
    """
        input: Column name
        output: Histogram plot
    """
    
    plt.figure()
    plt.hist(df[column], bins = 55, color = "orange")
    plt.xlabel(column)
    plt.ylabel("Frequency")
    plt.title(f"Data Frequency - {column}")
    plt.show()

# đồ thị biểu đồ cho các biến số
numerical_variables = ["housing_median_age", "total_rooms", "total_bedrooms",
                       "population", "households", "median_income", "median_house_value"]
for i in numerical_variables:
    plotHistogram(i)

"""#B5. Đào tạo mô hình hồi quy XGBoost

#Bây giờ chúng ta hãy bắt đầu đào tạo mô hình hồi quy của chúng ta! Trước tiên, chúng tôi sẽ cần chia dữ liệu của mình thành một mảng X chứa các tính năng để đào tạo và một mảng y có biến mục tiêu, trong trường hợp này là cột Giá. Chúng tôi sẽ loại bỏ cột Địa chỉ vì nó chỉ có thông tin văn bản mà mô hình hồi quy tuyến tính không thể sử dụng.

#mảng x và y

#Tiếp theo, hãy xác định các tính năng và nhãn. Tóm lại, tính năng là đầu vào; nhãn là đầu ra. Điều này áp dụng cho cả vấn đề phân loại và hồi quy.
"""

X = df[['housing_median_age', 'total_rooms', 'total_bedrooms','population', 'households','median_income','<1H OCEAN','INLAND','NEAR BAY','NEAR OCEAN']]
y = df['median_house_value']

"""#B6. Đào tạo - Kiểm tra - Tách

Bây giờ, hãy chia dữ liệu thành tập huấn luyện và tập kiểm tra. Chúng ta sẽ huấn luyện mô hình trên tập huấn luyện và sau đó sử dụng tập kiểm tra để đánh giá mô hình. Lưu ý rằng tôi đang sử dụng 40% dữ liệu để thử nghiệm

Trạng thái ngẫu nhiên là gì?

Nếu một số nguyên cho trạng thái ngẫu nhiên không được chỉ định trong mã, thì mỗi khi mã được thực thi, một giá trị ngẫu nhiên mới sẽ được tạo và tập dữ liệu huấn luyện và kiểm tra sẽ có các giá trị khác nhau mỗi lần. Tuy nhiên, nếu một giá trị cố định được gán -- như random_state = 0 hoặc 1 hoặc 101 hoặc bất kỳ số nguyên nào khác, thì cho dù bạn thực thi mã bao nhiêu lần thì kết quả vẫn như vậy, ví dụ: các giá trị giống nhau sẽ có trong tập dữ liệu huấn luyện và thử nghiệm. Do đó, trạng thái ngẫu nhiên mà bạn cung cấp được sử dụng làm nguồn gốc cho trình tạo số ngẫu nhiên. Điều này đảm bảo rằng các số ngẫu nhiên được tạo theo cùng một thứ tự.
"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.4, random_state=101)

"""#B7. Tạo và đào tạo

XGBoost là một thư viện tăng cường độ dốc phân tán được tối ưu hóa được thiết kế để mang lại hiệu quả cao, linh hoạt và di động.

XGBoost có thể được sử dụng trực tiếp cho mô hình dự đoán hồi quy.
"""

import xgboost as xgb
xg_reg = xgb.XGBRegressor(objective ='reg:squarederror', colsample_bytree = 1,eta=0.3, learning_rate = 0.1,
                max_depth = 5, alpha = 10, n_estimators = 2000)

"""Tôi cần làm điều này để đào tạo XGBoost vì nó cần bỏ qua các giá trị " , " từ mảng tính năng."""

import re
regex = re.compile(r"\[|\]|<", re.IGNORECASE)
X_train.columns = [regex.sub("_", col) if any(x in str(col) for x in set(('[', ']', '<'))) else col for col in X_train.columns.values]
X_test.columns = [regex.sub("_", col) if any(x in str(col) for x in set(('[', ']', '<'))) else col for col in X_test.columns.values]

xg_reg.fit(X_train,y_train)
y_pred2 = xg_reg.predict(X_test)

"""#B8. Đánh giá mô hình

Hãy đánh giá mô hình bằng cách kiểm tra các hệ số của nó và cách chúng ta có thể diễn giải chúng.
"""

grp = pd.DataFrame({'prediction':y_pred2,'Actual':y_test})
grp = grp.reset_index()
grp = grp.drop(['index'],axis=1)
plt.figure(figsize=(20,10))
plt.plot(grp[:120],linewidth=2)
plt.legend(['Actual','Predicted'],prop={'size': 20})

from sklearn.metrics import r2_score

r2xgb=r2_score(y_test,y_pred2)
print('the R squared of the xgboost method is:', r2xgb)

xgb.plot_importance(xg_reg)
plt.rcParams['figure.figsize'] = [5, 5]
plt.show()

"""#Dự đoán mô hình

"""

predictions = xg_reg.predict(X_test)

plt.scatter(y_test,predictions)